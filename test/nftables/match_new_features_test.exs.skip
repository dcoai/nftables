defmodule NFTables.MatchNewFeaturesTest do
  use ExUnit.Case, async: false
  require Logger

  @moduletag :integration
  @moduletag :new_features

  alias NFTables.{Table, Chain, Match, Query}
  import NFTables.QueryHelpers

  setup do
    {:ok, pid} = NFTables.start_link(port: NFTables.Port, check_capabilities: false)

    cleanup_tables(pid)

    :ok = Table.add(pid, %{name: "nftex_test_features", family: :inet})

    :ok =
      Chain.add(pid, %{
        table: "nftex_test_features",
        name: "INPUT",
        family: :inet
      })

    on_exit(fn ->
      if Process.alive?(pid) do
        cleanup_tables(pid)
        NFTables.stop(pid)
      end
    end)

    {:ok, pid: pid}
  end

  describe "port range matching" do
    test "match_port_range/3 creates valid rule", %{pid: pid} do
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.port_range(1024, 65535)
               |> Match.accept()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end

    test "match_udp_port_range/3 creates valid rule", %{pid: pid} do
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.udp_port_range(10000, 20000)
               |> Match.accept()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end
  end

  describe "ICMP matching" do
    test "match_icmp_type/2 with atom creates valid rule", %{pid: pid} do
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.icmp_type(:echo_request)
               |> Match.accept()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end

    test "match_icmp_type/2 with integer creates valid rule", %{pid: pid} do
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.icmp_type(8)
               |> Match.accept()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end

    test "match_icmp_code/2 creates valid rule", %{pid: pid} do
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.icmp_type(:dest_unreachable)
               |> Match.icmp_code(3)
               |> Match.accept()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end
  end

  describe "ICMPv6 matching" do
    test "match_icmpv6_type/2 creates valid rule", %{pid: pid} do
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.icmpv6_type(:echo_request)
               |> Match.accept()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end
  end

  describe "packet type matching" do
    test "match_pkttype/2 creates valid rule", %{pid: pid} do
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.pkttype(:broadcast)
               |> Match.drop()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end

    test "match_pkttype/2 with multicast creates valid rule", %{pid: pid} do
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.pkttype(:multicast)
               |> Match.accept()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end
  end

  describe "log levels" do
    test "log/3 with level creates valid rule", %{pid: pid} do
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.dest_port(22)
               |> Match.log("SSH: ", level: :warning)
               |> Match.accept()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end

    test "log/3 without level creates valid rule", %{pid: pid} do
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.log("TEST: ")
               |> Match.accept()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end
  end

  describe "mark save/restore" do
    test "restore_mark/1 creates valid rule", %{pid: pid} do
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.ct_state([:established, :related])
               |> Match.restore_mark()
               |> Match.accept()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end

    test "save_mark/1 creates valid rule", %{pid: pid} do
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.ct_state([:new])
               |> Match.set_mark(100)
               |> Match.save_mark()
               |> Match.accept()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end
  end

  describe "combined features" do
    test "complex rule with new features", %{pid: pid} do
      # Port range + ICMP + log level + mark operations
      assert :ok =
               Match.new(pid, "nftex_test_features", "INPUT")
               |> Match.port_range(8000, 9000)
               |> Match.ct_state([:new])
               |> Match.set_mark(10)
               |> Match.save_mark()
               |> Match.log("WEB-RANGE: ", level: :info)
               |> Match.accept()
               |> Match.commit()

      {:ok, rules} = list_rules(pid, "nftex_test_features", "INPUT", family: :inet)
      assert length(rules) > 0
    end
  end

  defp cleanup_tables(pid) do
    try do
      Table.delete(pid, "nftex_test_features", :inet)
    rescue
      _ -> :ok
    catch
      :exit, _ -> :ok
    end
  end
end
