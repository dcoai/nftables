defmodule NFTables.Formatter do
  @moduledoc """
  Convert nftables JSON expressions to nft command syntax strings.

  This module provides formatting functions to convert structured JSON
  expressions (generated by Match) into human-readable nft syntax
  strings for debugging, display, and documentation purposes.

  ## Examples

      # Format a single expression
      expr = %{"drop" => nil}
      Formatter.format_expr(expr)
      #=> "drop"

      # Format an expression list
      expr_list = [
        %{"match" => %{...}},
        %{"counter" => nil},
        %{"drop" => nil}
      ]
      Formatter.format_expr_list(expr_list)
      #=> "ip saddr 192.168.1.1 counter drop"

  ## Note

  This formatter covers 90%+ of common use cases. For complex or uncommon
  expressions, it may produce simplified output or fall back to JSON representation.
  """

  @doc """
  Format a single JSON expression to nft syntax.

  ## Examples

      format_expr(%{"accept" => nil})
      #=> "accept"

      format_expr(%{"match" => %{
        "left" => %{"payload" => %{"protocol" => "tcp", "field" => "dport"}},
        "right" => 80,
        "op" => "=="
      }})
      #=> "tcp dport 80"
  """
  @spec format_expr(map()) :: String.t()
  def format_expr(expr) when is_map(expr) do
    cond do
      # Verdicts
      Map.has_key?(expr, "accept") -> "accept"
      Map.has_key?(expr, "drop") -> "drop"
      Map.has_key?(expr, "continue") -> "continue"
      Map.has_key?(expr, "return") -> "return"
      Map.has_key?(expr, "reject") -> format_reject(expr["reject"])
      Map.has_key?(expr, "jump") -> format_jump(expr["jump"])
      Map.has_key?(expr, "goto") -> format_goto(expr["goto"])
      # Statements
      Map.has_key?(expr, "counter") -> "counter"
      Map.has_key?(expr, "log") -> format_log(expr["log"])
      Map.has_key?(expr, "limit") -> format_limit(expr["limit"])
      Map.has_key?(expr, "mangle") -> format_mangle(expr["mangle"])
      Map.has_key?(expr, "ct") && is_map(expr["ct"]) -> format_ct_set(expr["ct"])
      # NAT
      Map.has_key?(expr, "snat") -> format_snat(expr["snat"])
      Map.has_key?(expr, "dnat") -> format_dnat(expr["dnat"])
      Map.has_key?(expr, "masquerade") -> format_masquerade(expr["masquerade"])
      # Matches
      Map.has_key?(expr, "match") -> format_match(expr["match"])
      # Unknown/unsupported
      true -> format_fallback(expr)
    end
  end

  def format_expr(expr) when is_binary(expr), do: expr
  def format_expr(expr), do: inspect(expr)

  @doc """
  Format a list of JSON expressions to nft syntax.

  ## Examples

      format_expr_list([
        %{"match" => %{...}},
        %{"counter" => nil},
        %{"drop" => nil}
      ])
      #=> "ip saddr 192.168.1.1 counter drop"
  """
  @spec format_expr_list(list()) :: String.t()
  def format_expr_list(expr_list) when is_list(expr_list) do
    expr_list
    |> Enum.map(&format_expr/1)
    |> Enum.join(" ")
  end

  def format_expr_list(expr), do: format_expr(expr)

  ## Verdict Formatters

  defp format_reject(nil), do: "reject"

  defp format_reject(%{"type" => type}) when is_binary(type) do
    "reject with #{type}"
  end

  defp format_reject(_), do: "reject"

  defp format_jump(%{"target" => target}), do: "jump #{target}"
  defp format_jump(_), do: "jump"

  defp format_goto(%{"target" => target}), do: "goto #{target}"
  defp format_goto(_), do: "goto"

  ## Statement Formatters

  defp format_log(log_expr) when is_map(log_expr) do
    parts = ["log"]

    parts =
      if prefix = log_expr["prefix"] do
        parts ++ ["prefix #{inspect(prefix)}"]
      else
        parts
      end

    parts =
      if level = log_expr["level"] do
        parts ++ ["level #{level}"]
      else
        parts
      end

    parts =
      if flags = log_expr["flags"] do
        flag_str = Enum.join(List.wrap(flags), ",")
        parts ++ ["flags #{flag_str}"]
      else
        parts
      end

    Enum.join(parts, " ")
  end

  defp format_log(_), do: "log"

  defp format_limit(limit_expr) when is_map(limit_expr) do
    rate = limit_expr["rate"]
    per = limit_expr["per"]
    burst = limit_expr["burst"]
    inv = limit_expr["inv"]

    parts = ["limit", "rate"]

    parts =
      if inv do
        parts ++ ["over"]
      else
        parts
      end

    parts = parts ++ ["#{rate}/#{per}"]

    parts =
      if burst do
        parts ++ ["burst #{burst} packets"]
      else
        parts
      end

    Enum.join(parts, " ")
  end

  defp format_limit(_), do: "limit"

  defp format_mangle(%{"key" => key, "value" => value}) do
    case format_expr_operand(key) do
      "meta " <> meta_key -> "meta #{meta_key} set #{format_value(value)}"
      "payload " <> payload -> "#{payload} set #{format_value(value)}"
      other -> "#{other} set #{format_value(value)}"
    end
  end

  defp format_mangle(_), do: "mangle"

  defp format_ct_set(%{"key" => key, "value" => value}) do
    "ct #{key} set #{format_value(value)}"
  end

  defp format_ct_set(_), do: "ct"

  ## NAT Formatters

  defp format_snat(snat_expr) when is_map(snat_expr) do
    addr = snat_expr["addr"]
    port = snat_expr["port"]

    if port do
      "snat ip to #{addr}:#{format_port_value(port)}"
    else
      "snat ip to #{addr}"
    end
  end

  defp format_snat(_), do: "snat"

  defp format_dnat(dnat_expr) when is_map(dnat_expr) do
    addr = dnat_expr["addr"]
    port = dnat_expr["port"]

    if port do
      "dnat ip to #{addr}:#{format_port_value(port)}"
    else
      "dnat ip to #{addr}"
    end
  end

  defp format_dnat(_), do: "dnat"

  defp format_masquerade(nil), do: "masquerade"

  defp format_masquerade(masq_expr) when is_map(masq_expr) do
    if port = masq_expr["port"] do
      "masquerade to :#{format_port_value(port)}"
    else
      "masquerade"
    end
  end

  defp format_masquerade(_), do: "masquerade"

  ## Match Formatters

  defp format_match(%{"left" => left, "right" => right, "op" => op}) do
    left_str = format_expr_operand(left)
    right_str = format_value(right)
    op_str = format_operator(op)

    # Simple equality can omit operator
    if op == "==" do
      "#{left_str} #{right_str}"
    else
      "#{left_str} #{op_str} #{right_str}"
    end
  end

  defp format_match(_), do: "match"

  ## Operand Formatters

  defp format_expr_operand(%{"payload" => %{"protocol" => proto, "field" => field}}) do
    "#{proto} #{field}"
  end

  defp format_expr_operand(%{"ct" => %{"key" => key, "dir" => dir}}) do
    "ct #{dir} #{key}"
  end

  defp format_expr_operand(%{"ct" => %{"key" => key}}) do
    "ct #{key}"
  end

  defp format_expr_operand(%{"meta" => %{"key" => key}}) do
    "meta #{key}"
  end

  defp format_expr_operand(%{"&" => [expr, mask]}) do
    # Bitwise AND for TCP flags, fragmentation, etc.
    expr_str = format_expr_operand(expr)
    mask_str = format_value(mask)
    "#{expr_str},#{mask_str}"
  end

  defp format_expr_operand(operand) when is_map(operand) do
    # Unknown operand, try to format as generic
    inspect(operand)
  end

  defp format_expr_operand(operand), do: to_string(operand)

  ## Value Formatters

  defp format_value(value) when is_binary(value) do
    # Check if it's a set reference
    if String.starts_with?(value, "@") do
      value
    else
      value
    end
  end

  defp format_value(value) when is_integer(value), do: to_string(value)

  defp format_value(value) when is_list(value) do
    # List of values (e.g., CT states)
    Enum.join(value, ",")
  end

  defp format_value(%{"range" => [min_val, max_val]}) do
    "#{format_value(min_val)}-#{format_value(max_val)}"
  end

  defp format_value(%{"prefix" => %{"addr" => addr, "len" => len}}) do
    "#{addr}/#{len}"
  end

  defp format_value(value) when is_map(value) do
    # Unknown structure, try to inspect
    inspect(value)
  end

  defp format_value(value), do: to_string(value)

  defp format_port_value([min_port, max_port]) do
    "#{min_port}-#{max_port}"
  end

  defp format_port_value(port) when is_integer(port) do
    to_string(port)
  end

  defp format_port_value(port), do: to_string(port)

  ## Operator Formatters

  defp format_operator("=="), do: "=="
  defp format_operator("!="), do: "!="
  defp format_operator("<"), do: "<"
  defp format_operator(">"), do: ">"
  defp format_operator("<="), do: "<="
  defp format_operator(">="), do: ">="
  defp format_operator("in"), do: "in"
  defp format_operator(op), do: op

  ## Fallback Formatter

  defp format_fallback(expr) do
    # For unsupported expressions, show as JSON for debugging
    try do
      json = JSON.encode!(expr)
      "[JSON: #{json}]"
    rescue
      _ -> "[UNKNOWN: #{inspect(expr)}]"
    end
  end
end
